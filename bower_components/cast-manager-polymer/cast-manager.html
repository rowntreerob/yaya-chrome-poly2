<!--
Copyright 2014 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-signals/iron-signals.html">

<link rel="import" href="media-item.html">
<link rel="import" href="queue-manager.html">

<!--
The `cast-manager` element is the controller for all of the cast elements.  It routes events,
manages and syncs states and handles all of the casting/local logic for controlling media.  It exposes
state for other elements to then bind to.

Example:
    <cast-manager app-id="4F8B3483"
                cast-available="{{castAvailable}}"
                connection-status="{{connectionStatus}}"
                local-media="{{localMedia}}"
                queue="{{queue}}"
                volume="{{volume}}"
                has-cast-media="{{hasCastMedia}}"
                show-queue="{{showQueue}}"
                cast-device-name="{{castDeviceName}}"
                current-time="{{currentTime}}"
                is-fullscreen="{{isFullscreen}}"
                show-spinner="{{showSpinner}}"
                next-queue-media-item="{{nextQueueMediaItem}}"
                countdown-to-next-media-item="{{countdownToNextMediaItem}}">
    </cast-manager>

`cast-manager` stores both state and fires events.  Events are meant to initiate actions.  For
example if a user presses play on the player bar, that element bubbles up the event to `cast-manager`.  `cast-manager` then
fires a iron event notifying any listening elements to take action.  Once the action has occured,
 the element then updates state which is 2 way bound to update the property in `cast-manager`.

Use the `helper-behavior` to easily add queueing and media control functionality into your app.
-->

<script>
  var cast = window.cast || {};
  (function () {
    'use strict';

    var CastManager = Polymer({
      is: 'cast-manager',
      properties: {
        /**
         * Id defining the receiver app
         */
        appId: String,

        /**
         * Media object to display in format `cast.MediaItem`
         */
        localMedia: {
          type: Object,
          notify: true
        },

        /**
         * Reference to loaded `chrome.cast.media`
         */
        castMedia: {
          type: Object,
          notify: true
        },

        /**
         * `cast.QueueManager` instance to store the current state of the queue
         */
        queue: {
          type: Object,
          notify: true,
          value: function () {
            return new cast.QueueManager();
          }
        },

        /**
         * Spinner state
         */
        showSpinner: {
          type: Boolean,
          notify: true,
          value: false
        },

        /**
         * Cast connection state.
         *
         * Values defined by cast.CastManager.CONNECTION_STATUS
         */
        connectionStatus: {
          type: Number,
          notify: true,
          value: 0 //CastManager.CONNECTION_STATUS
        },

        /**
         * Reference to loaded `chrome.cast.Session`
         */
        session: {
          type: Object,
          notify: true
        },

        /**
         * Boolean defining if a cast receiver is available to cast to.
         */
        castAvailable: {
          type: Boolean,
          notify: true,
          value: false
        },

        /**
         * Current media volume syncs to both local and cast media.
         */
        volume: {
          type: Number,
          value: .5,
          notify: true
        },

        /**
         * `currentTime` of media syncs to both local and cast media
         */
        currentTime: {
          type: Number,
          value: 0,
          notify: true,
          observer: ['_currentTimeObserver']
        },

        /**
         * Name of the connected cast device
         */
        castDeviceName: {
          type: String,
          value: 'Local Player',
          notify: true
        },

        /**
         * State defining if the queue is shown or hidden
         */
        isQueueShown: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * State defining if media is loaded onto the cast
         */
        hasCastMedia: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * State defining if the video element is fullscreened
         */
        isFullscreen: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * `cast.MediaItem` defining the next item in queue
         */
        nextQueueMediaItem: {
          type: Object,
          notify: true
        },

        /**
         * Time in seconds until the next video starts
         */
        countdownToNextMediaItem: {
          type: Number,
          notify: true,
          value: null
        }
      },
      /**
       * Reference to the interval that polls and updates currentTime
       */
      _timerHandle: null,

      /**
       * `cast.QueueManager` to store the local queue when casting.
       *
       * If the receiver has an existing queue and the local device has a queue, the local device
       * queue will be saved when it connects to the receiver.  When the local device
       * disconnects, the previous queue is restored.
       *
       * If reciever has no existing queue or if casting initiates a new session, the cast device
       * queue will persist when the local device disconnects.
       */
      _savedQueue: null,

      /**
       * Boolean describing whether or not to restore to previous saved queue.
       */
      _loadSavedQueueOnDisconnect: true,

      /**
       * Time in seconds to display the upcoming video notification
       */
      _preloadTime: 20,

      /**
       * Reference to an async task that tries reloading local media if it doesn't load
       * the first time.
       */
      _retryHandler: null,

      //Listeners for fired events from sub elements
      listeners: {
        'toggleCastConnection': 'toggleCastConnection',
        'queueEvent': '_onQueueEvent',
        'mediaActionEvent': '_onMediaActionEvent'
      },

      ready: function () {
        // Init cast
        this.init();
        //TODO(pying): make sure this works for a single video
        //TODO(pying): test against slow networks
      },

      /**
       * Init chromecast, and look for receivers
       */
      init: function () {
        //Only init cast for chrome browsers
        if (this.appId !== null
            && window.chrome !== null
            && window.chrome !== undefined
            && window.navigator.vendor === 'Google Inc.') {
          //Inject chromecast script
          var castScript = document.createElement('script');
          castScript.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js';
          document.getElementsByTagName('head')[0].appendChild(castScript);

          // Init cast
          var initializeCastApi = function () {
            if (!chrome.cast || !chrome.cast.isAvailable) {
              window.setTimeout(initializeCastApi.bind(this), 500);
            } else {
              var sessionRequest = new chrome.cast.SessionRequest(this.appId);
              var apiConfig = new chrome.cast.ApiConfig(sessionRequest,
                  this._sessionListener.bind(this),
                  this._receiverListener.bind(this));
              chrome.cast.initialize(apiConfig, this._initSuccess, this._initFailure);
            }
          };
          initializeCastApi.call(this);
        } else {
          console.log('Browser is not Chrome, not enabling cast functionality');
        }
      },
      /********* Event Handlers & Callbacks  ********/

      /**
       * Listener invoked when a session is created or connected.
       */
      _sessionListener: function (session) {
        console.log('SessionListener: Session changed');
        if (session.status === chrome.cast.SessionStatus.CONNECTED) {
          console.log('SessionListener: Session connected');
          //Listen for any changes to the session
          session.addUpdateListener(this._sessionUpdateListener.bind(this));

          this.set('connectionStatus', cast.CastManager.CONNECTION_STATUS.CONNECTED);

          //Store a local reference to the session and set our receiver name
          this.setSession(session);

          // Check if the session has existing media
          if (session.media.length > 0
              && session.media[0].playerState !== chrome.cast.media.PlayerState.IDLE) {
            // If the session has existing media update local info with media details
            this._onMediaDiscovered(session.media[0]);
          } else if (this.queue.items.length > 0) {
            this._loadSavedQueueOnDisconnect = false;
            this.castLoadItems(this.queue.items);
          } else if (this.localMedia) {
            this.loadMediaOntoCast(this.localMedia, true);
          }
        }
      },

      /**
       * Listens for session changes
       */
      _sessionUpdateListener: function () {
        //If session is disconnected revert to local player
        if (this.session.status !== chrome.cast.SessionStatus.CONNECTED) {
          console.log('SessionListener: Session disconnected');
          this._onStopSuccess();
        }
      },

      /**
       * Handles receiver update events
       */
      _receiverListener: function (e) {
        console.log('receiver listener');
        this.set('castAvailable', e === chrome.cast.ReceiverAvailability.AVAILABLE);
      },

      /**
       * Cast initialization success
       */
      _initSuccess: function () {
        console.log('Cast init success');
      },

      /**
       * Cast initialization failure
       */
      _initFailure: function () {
        console.long('Cast init failure' + JSON.stringify(e));
      },


      /**
       * When new media is discovered, attach a handler to listen for further events
       * and sync the current local media state with the casting media.
       *
       * If the cast device has no previous media, this method will match the cast device seek
       * and player state to local media.
       *
       * If the cast device is already casting something, this method will match local media to
       * the casting media.
       */
      _onMediaDiscovered: function (media) {
        //Store reference to media object
        this.setCastMedia(media);

        //Add listener for media changes
        media.addUpdateListener(this._onCastMediaUpdate.bind(this));

        //Copy over remote queue to local queue if it's not empty
        if (media.items !== null) {
          this._queueSwitchFromLocalToCast(media.items);
        }
        this._onCastMediaUpdate();
      },

      /**
       * Called when cast media changes.  Syncs the differences between cast media and local media
       */
      _onCastMediaUpdate: function () {
        console.log('Cast media changed ' +this.castMedia.playerState);

        //If the session still has media sync
        if (this.castMedia) {
          //Parse the queue and update our local representation
          this.queue.parseCastQueue(this.castMedia.items);

          //Sync localMedia if it's different or if localMedia doesn't exist or have a queueId
          if (!this.localMedia || !this.localMedia.queueId || (this.castMedia.currentItemId &&
              this.localMedia.queueId !== this.castMedia.currentItemId)) {
            this.setLocalMedia(this.queue.getItemById(this.castMedia.currentItemId));
          }

          //Sync the volume
          this.volume = this.castMedia.volume.level;

          //Sync the repeat/shuffle state
          this._repeatModeSyncer();

          //Sync the playing state
          this._castPlayerStateSyncer();

          // Hide preload dialog
          if (this.castMedia.playerState !== chrome.cast.media.PlayerState.BUFFERING &&
              this.castMedia.preloadedItemId === null) {
            this._resetState();
            this.hidePreloadDialog();
          }
          if (this.castMedia.currentItemId) {
            // Sync queue current index which is used sometimes after disconnect
            this.queue.setCurrentIndex(this.queue.getIndexOfId(this.castMedia.currentItemId));
          } else {
            // When cast content ends the currentItemId is null but castMedia is still defined.
            // In this case we need to load new media which is typically reserved for when cast
            // media isn't loaded.
            this.set('hasCastMedia', false);
          }
        } else {
          //Otherwise update that cast media is null
          this.set('hasCastMedia', false);
        }
      },

      /**
       * Syncs the cast repeat mode with the local repeat mode
       */
      _repeatModeSyncer: function () {
        var repeatMode = this._castQueueRepeatModeToLocalRepeatMode(this.castMedia.repeatMode);
        var shuffle = this._castQueueRepeatModeToLocalShuffle(this.castMedia.repeatMode);
        this.queue.setRepeatMode(repeatMode);
        this.queue.setShuffle(shuffle);
      },

      /**
       * Syncs remote player state with local player state
       */
      _castPlayerStateSyncer: function () {
        //Sync local player state with cast player state
        this.localMedia.setState(
            this._castPlayerStateToLocalPlayerState(this.castMedia.playerState));

        //If the media is playing start an interval to update the currentTime
        if (this.castMedia.playerState === chrome.cast.media.PlayerState.PLAYING) {
          this._hideSpinner();
          // If the media is playing, set an interval to calculate elapsed time
          if (this._timerHandle === null) {
            this._timerHandle = window.setInterval(function () {
              this.set('currentTime', this.castMedia.getEstimatedTime());
            }.bind(this), 1000);
          }
        } else {
          // Otherwise clear the interval and reset previous time
          window.clearInterval(this._timerHandle);
          this._timerHandle = null;
        }
      },

      /**
       * Media load error callback
       * @param {Object} e error details
       */
      _onMediaError: function (e) {
        console.log('Media error: ' + JSON.stringify(e));
      },

      /**
       * Called when a new session is created
       *
       * @param {chrome.cast.Session} session cast session
       */
      _onRequestSessionSuccess: function (session) {
        console.log('Request session success');

        //Set the session update
        this._sessionListener(session);
      },

      /**
       * Called when session request fails
       * @param {Object} e error
       */
      _onRequestSessionFailure: function (e) {
        console.log('Request session failure: ' + JSON.stringify(e));

        this.set('connectionStatus', cast.CastManager.CONNECTION_STATUS.DISCONNECTED);
      },

      /**
       * Generic success callback
       * @param {Object} msg callback data
       */
      _onGenericSuccess: function (msg) {
        console.log('Generic success: ' + JSON.stringify(msg));
      },

      /**
       * Generic failure callback
       * @param {Object} msg callback data
       */
      _onGenericFailure: function (msg) {
        console.log('Generic failure: ' + JSON.stringify(msg));
      },


      /**
       * Handles disconnection and updates states to control local content
       */
      _onStopSuccess: function () {
        // Clear timer
        window.clearInterval(this._timerHandle);

        // Set connection status to disconnected
        this.set('connectionStatus', cast.CastManager.CONNECTION_STATUS.DISCONNECTED);
        this.set('hasCastMedia', false);
        this.set('session', null);

        if (this._loadSavedQueueOnDisconnect && this._savedQueue !== null) {
          // Revert to previous queue
          this.set('queue', this._savedQueue);

          // Revert to last playing item
          this.setLocalMedia(this.queue.getCurrentItem());
          this._loadSavedQueueOnDisconnect = true;
        } else {
          // Sync local media to the last state of the queue
          this.seek(this.currentTime, cast.CastManager.SENDER.LOCAL);
          this.pause(cast.CastManager.SENDER.LOCAL);
        }

        this._resetState();
        console.log('Disconnecting succeeded');
      },

      /**
       * Stop request failure callback
       * @param {Object} e error response
       */
      _onStopFailure: function (e) {
        console.log('Disconnecting failure: ' + JSON.stringify(e));
      },

      /**
       * Event dispatcher for queue events from child elements.  Covers adding and removing items
       * from queue etc.
       * @param {Object} event event details including method and params
       */
      _onQueueEvent: function (event) {
        this[event.detail.type].apply(this, event.detail.args);
      },

      /**
       * Event dispatcher for media action events from child elements.  Covers play, pause, seek,
       * etc.
       * @param {Object} event event details including method and params
       */
      _onMediaActionEvent: function (event) {
        this[event.detail.type].apply(this, event.detail.args);
      },

      /********************** Actions & public methods ************************/
      /**
       * Start a casting session
       */
      startCast: function () {
        //update connection status
        this.set('connectionStatus', cast.CastManager.CONNECTION_STATUS.CONNECTING);

        //request a session
        chrome.cast.requestSession(this._onRequestSessionSuccess.bind(this),
            this._onRequestSessionFailure.bind(this));
      },

      /**
       * Sets a local reference to `chrome.cast.Session` and the device name
       *
       * @param {chrome.cast.Session} session chromecast session
       */
      setSession: function (session) {
        this.set('session', session);
        this.set('castDeviceName', session.receiver.friendlyName);
      },

      /**
       * Sets a local reference to `chrome.cast.media`
       *
       * @param {chrome.cast.media} media chromecast media
       */
      setCastMedia: function (media) {
        this._hideSpinner();
        this.set('hasCastMedia', true);
        this.set('castMedia', media);
      },

      /**
       * Sets local media and fires an iron event to notify elements of the change
       *
       * @param {cast.MediaItem} media item to load
       */
      setLocalMedia: function (media) {
        this.queue.resetNextItem();
        this.set('localMedia', new cast.MediaItem(media));

        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'loadMedia',
            'thumbnailImageUrl': media.thumbnailImageUrl,
            'url': media.url
          }
        });

        // Retry loading the item if an issue occurs
        this._retryHandler = this.async(function () {
          console.log('retrying setting the local media');
          this.setLocalMedia(media);
        }, 12000);
      },

      /**
       * Loads a `cast.MediaItem` onto cast when a session exists.
       *
       * @param {cast.MediaItem} media media to load
       * @param {Boolean} autoplay boolean defining whether the media should auto play
       */
      loadMediaOntoCast: function (media, autoplay) {
        // Convert local media to cast media
        var mediaInfo = this._localMediaToCastMedia(media);

        // Create a load request
        var request = new chrome.cast.media.LoadRequest(mediaInfo);
        request.autoplay = autoplay;
        request.currentTime = this.currentTime;

        // Load the media
        this.session.loadMedia(request, this._onMediaDiscovered.bind(this),
            this._onMediaError.bind(this));
      },

      /**
       * Returns true if a receiver is currently connected
       *
       * @returns {Boolean} returns true if a receiver is currently connected
       */
      isCasting: function () {
        return this.connectionStatus === cast.CastManager.CONNECTION_STATUS.CONNECTED;
      },

      /**
       * Toggles the cast connection
       */
      toggleCastConnection: function () {
        //If connected, disconnected
        if (this.isCasting()) {
          this.stopCasting();
        } else {
          //otherwise connect to cast
          this.exitFullscreen();
          this.startCast();
        }
      },

      /**
       * Fires an iron event to toggle the queue controller from hidden to shown
       */
      toggleQueueElement: function () {
        console.log('Toggle queue element');

        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'toggleQueueElement',
            "isQueueShown": this.isQueueShown
          }
        });
      },

      /**
       * Inserts media into queue and immediately plays it.  Also fires a playNow iron event
       *
       * @param {cast.MediaItem} media media to play
       */
      playNow: function (media) {
        console.log('Play now: ' + media.url);
        // Send playNow Event to listening elements
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'playNow',
            'media': media
          }
        });

        if (this.hasCastMedia) {
          //Get the id of the current index
          var currentIndex = this.queue.getIndexOfId(this.castMedia.currentItemId);

          //Success handler for Play now insertion to automatically play the inserted item
          var successHandler = function (data) {
            this.castQueuePlayItem(this.castMedia.items[currentIndex].itemId);
          }.bind(this);
          var index = (currentIndex !== -1) ? this.castMedia.currentItemId : null;

          if (this.castMedia.queueInsertAndPlayItem) {
            this.castQueueInsertAndPlayItem(media, index, true);
          } else {
            this.castQueueInsertItems([media], index,
                successHandler.bind(this), true);
          }
        } else if (this.session && this.session.status === chrome.cast.SessionStatus.CONNECTED) {
          this.loadMediaOntoCast(media, true);
        } else {
          //Since inserting items automatically updates index, store a copy of it
          var tmpIndex = (this.queue.currentIndex) ? this.queue.currentIndex : 0;
          this.queue.insertItemsAtIndex([media], this.queue.currentIndex);

          //And reset it later on
          this.queue.setCurrentIndex(tmpIndex);

          this.setLocalMedia(this.queue.getCurrentItem());
        }
      },

      /**
       * Inserts an item as the next item in queue.  Also fires an iron even to notify of the
       * insertion
       *
       * @param {cast.MediaItem} media media to insert
       */
      playNext: function (media) {
        console.log('Play next: ' + media.url);
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'playNext',
            'media': media
          }
        });

        if (this.hasCastMedia) {
          // Get the index of currently casting item
          var currentIndex = this.queue.getIndexOfId(this.castMedia.currentItemId);

          // If index is found and next item exists then insert the media before the next item id
          if (currentIndex !== -1 && currentIndex + 1 < this.castMedia.items.length) {
            var nextElementId = this.queue.items[currentIndex + 1].queueId;
            this.castQueueInsertItems([media], nextElementId, null, true);
          } else {
            // Otherwise insert the item at the end of the queue
            this.castQueueInsertItems([media], null, null, true);
          }
        } else if (this.session && this.session.status === chrome.cast.SessionStatus.CONNECTED) {
          this.loadMediaOntoCast(media, true);
        } else {
          this.queue.insertItemsAtIndex([media], this.queue.currentIndex + 1);
        }
      },

      /**
       * Move a queue item to a new index.  Also fires an iron event to notify of the move
       *
       * @param {Number} itemId id of item to move
       * @param {newIndex} index index to insert item at
       */
      queueMoveItemToNewIndex: function (itemId, newIndex) {
        console.log('Move item to new index id: ' + itemId + ' index: ' + newIndex);
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'queueMoveItemToNewIndex',
            'itemId': itemId,
            'newIndex': newIndex
          }
        });

        if (this.hasCastMedia) {
          this.castQueueMoveItem(itemId, newIndex);
        } else {
          this.queue.moveItemToNewIndex(itemId, newIndex);
        }
      },

      /**
       * Plays a specific item in the queue
       * @param {cast.MediaItem} media queue item to play
       */
      queuePlayItem: function (media) {
        console.log('Playing queue item with id: ' + media.queueId);
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'queuePlayItem',
            'media': media
          }
        });

        if (this.hasCastMedia) {
          this.castQueuePlayItem(media.queueId);
        } else {
          this.queue.setCurrentIndex(this.queue.getIndexOfId(media.queueId));
          this.setAutoPlayTrigger(true);
          this.setLocalMedia(this.queue.getCurrentItem());
        }
      },

      /**
       * Empty the current queue
       */
      queueEmpty: function () {
        console.log('Queue empty');

        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'queueEmpty'
          }
        });

        if (this.hasCastMedia) {
          var itemIdsToRemove = [];
          // Get IDs of queue elements to remove
          for (var i = 0; i < this.castMedia.items.length; i++) {
            itemIdsToRemove.push(this.castMedia.items[i].itemId);
          }
          // Pass the IDs as an array to cast
          this.castQueueRemoveItems(itemIdsToRemove);
        } else {
          this.queue.empty();
        }
      },

      /**
       * Toggle the queue shuffle mode
       */
      queueToggleShuffle: function () {
        console.log('Toggling shuffle mode');
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'queueToggleShuffle'
          }
        });
        this.queue.toggleShuffle();

        //Cast has no toggle concept so we set it to a specific value
        if (this.isCasting()) {
          this.castSetRepeat(this._localQueueToCastQueueRepeatMode(this.queue));
        }
      },

      /**
       * Toggle the queue repeat mode
       */
      queueToggleRepeatMode: function () {
        console.log('Toggling repeat mode');

        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'queueToggleRepeatMode'
          }
        });
        this.queue.toggleRepeatMode();

        //Cast has no toggle concept so we set it to a specific value
        if (this.isCasting()) {
          this.castSetRepeat(this._localQueueToCastQueueRepeatMode(this.queue));
        }
      },

      /**
       * Sends a request to cast to disconnect
       */
      stopCasting: function () {
        this.session.stop(this._onStopSuccess.bind(this),
            this._onStopFailure.bind(this));
      },

      /**
       * Fires an iron event to request full screen.  Typically the video element handles this
       * request and fullscreens itself.
       */
      fullscreen: function () {
        console.log('Fullscreen');
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'fullscreen'
          }
        });
      },

      /**
       * Fire an event to exit full screen
       */
      exitFullscreen: function () {
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'exitFullscreen'
          }
        });
      },

      /**
       * Add an array of `cast.MediaItem`s to the queue
       *
       * @param {Array} items array of `cast.MediaItem`s to add to the queue at the end
       */
      addItemsToQueue: function (items) {
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'addItemsToQueue',
            'items': items
          }
        });

        //If casting then add to cast queue
        if (this.hasCastMedia) {
          this.castQueueInsertItems(items, null, null, true);
        } else if (this.session && this.session.status === chrome.cast.SessionStatus.CONNECTED) {
          this.castLoadItems(items);
        } else { //Otherwise add to local queue
          this.queue.pushAll(items);
          if (!this.localMedia) {
            this.setLocalMedia(this.queue.getCurrentItem());
          }
        }
      },

      /**
       * Removes an item from the queue.  It does so by looking at the item's queueId so, the
       * queueId must match not a reference comparison.
       *
       * @param {cast.MediaItem} media queue item to remove
       */
      queueRemoveItem: function (media) {
        console.log('Removing item from queue: ', media.queueId);
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'queueRemoveItem',
            'media': media
          }
        });
        if (this.hasCastMedia) {
          this.castQueueRemoveItems([media.queueId]);
        } else {
          this.queue.removeItemWithId(media.queueId);
        }
      },

      /**
       * Loads the next item from the queue
       */
      queueLoadNextItem: function () {
        var mediaItem = this.queue.getNextItem();
        if (mediaItem) {
          this.setLocalMedia(mediaItem);
        }
      },

      /**
       * Covert Array of `cast.MediaItem` to `chrome.cast.media.MediaInfo` and load them onto cast
       *
       * @param {Array} items Array of `cast.MediaItem`s to load.
       */
      castLoadItems: function (items) {
        if (items.length > 0) {
          this._showSpinner();

          //Convert local queue items to cast queue Items
          var itemsToAdd = [];
          for (var i = 0; i < items.length; i++) {
            itemsToAdd[i] = new chrome.cast.media.QueueItem(
                this._localMediaToCastMedia(items[i]));
            itemsToAdd[i].preloadTime = 20;
            if (this.localMedia.queueId && items[i].queueId === this.localMedia.queueId &&
                this.currentTime !== 0) {
              itemsToAdd[i].startTime = this.currentTime;
            }
          }
          var request = new chrome.cast.media.QueueLoadRequest(itemsToAdd);
          request.startIndex = this.queue.currentIndex;
          request.repeatMode = this._localQueueToCastQueueRepeatMode(this.queue);

          this.session.queueLoad(request, this._onMediaDiscovered.bind(this), this._onMediaError);
        }
      },


      /**
       * Inserts an item and immediately plays it when casting
       *
       * @param {cast.MediaItem} media media to play
       * @param {Number} insertBefore Id of element to insert before
       */
      castQueueInsertAndPlayItem: function (media, insertBefore) {
        var queueItem, request;
        if (this.castMedia.queueInsertAndPlayItem) {

          queueItem = new chrome.cast.media.QueueItem(this._localMediaToCastMedia(media));
          queueItem.autoplay = true;
          queueItem.preloadTime = this._preloadTime;

          request = new chrome.cast.media.QueueInsertAndPlayItemRequest(queueItem);
          request.insertBefore = insertBefore;

          this.castMedia.queueInsertAndPlayItem(request, this._onGenericSuccess.bind(this),
              this._onGenericFailure.bind(this));
        }
      },

      /**
       * Converts local media items to cast items then inserts them.  If insertBefore is
       * defined it inserts the items before the insertBefore itemId.  Otherwise it inserts the
       * items at the beginning.
       *
       * @param {cast.MediaItem} media media to play
       * @param {Number} insertBefore Id of element to insert before
       * @param {Function} successCallback callback on insert success
       * @param {Boolean} autoplay boolean defining if the media should be autoplayed
       */
      castQueueInsertItems: function (media, insertBefore, successCallback, autoplay) {
        var queueItem, request;

        //Convert local media items to cast media items
        var itemsToAdd = [];
        for (var i = 0; i < media.length; i++) {
          queueItem = new chrome.cast.media.QueueItem(this._localMediaToCastMedia(media[i]));
          queueItem.autoplay = autoplay;
          queueItem.preloadTime = this._preloadTime;
          itemsToAdd.push(queueItem);
        }

        //Create the insert request
        request = new chrome.cast.media.QueueInsertItemsRequest(itemsToAdd);
        request.insertBefore = insertBefore;
        if (successCallback === null) {
          successCallback = this._onGenericSuccess.bind(this);
        }

        //Insert the media
        this.castMedia.queueInsertItems(request, successCallback,
            this._onGenericFailure.bind(this));

      },

      /**
       * Plays the item matching the specified ID.
       *
       * @param {Number} itemId ID of item to play
       */
      castQueuePlayItem: function (itemId) {
        if (this.hasCastMedia) {
          this.castMedia.queueJumpToItem(itemId, this._onGenericSuccess.bind(this),
              this._onGenericFailure.bind(this));
        }
      },

      /**
       * Removes items from queue from an array of IDs.
       *
       * @param itemIds {array} itemIds of elements to remove
       */
      castQueueRemoveItems: function (itemIds) {
        var removeRequest = new chrome.cast.media.QueueRemoveItemsRequest(itemIds);
        this.castMedia.queueRemoveItems(removeRequest
            , this._onGenericSuccess.bind(this)
            , this._onGenericFailure.bind(this));
      },

      /**
       * Moves an item in the cast queue to a new index
       *
       * @param {Number} itemId id of item to move
       * @param {Number} newIndex index to move item to
       */
      castQueueMoveItem: function (itemId, newIndex) {
        this.castMedia.queueMoveItemToNewIndex(itemId, newIndex, this._onGenericSuccess.bind(this),
            this._onGenericFailure.bind(this));
      },

      /**
       * Handles local media loaded event fired by the video element
       */
      mediaLoaded: function () {
        console.log('Media finished loading locally');
        // Prevent the load media retry
        this.cancelAsync(this._retryHandler);
        this._retryHandler = null;

        // Reset local spinners
        this._resetState();

        // Fire an event to notify other elements that media has completed loading
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'mediaLoaded'
          }
        });
      },

      /**
       * Returns true if the casting media matches local media
       *
       * @return {Boolean} True if the casting media exists and matches local media
       */
      isMediaMatch: function () {
        return !!(this.castMedia && this.castMedia.media.contentId === this.localMedia.url);
      },

      /**
       * Returns true if cast has a session media and the local media matches remote media
       */
      isCastActionable: function (sender) {
        return !!((this.session && this.hasCastMedia &&
        sender !== cast.CastManager.SENDER.CHROMECAST));
      },
      /************* Control functions ****************/

      /**
       * Fire a seek iron signals event and seek the video to the request time in seconds
       *
       * @param {Number} time time in seconds to seek to
       * @param {cast.CastManager.SENDER} sender requesting element
       */
      seek: function (time, sender) {
        console.log('Seek: ' + time + ' ' + sender);
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'seek',
            'currentTime': time,
            'sender': sender
          }
        });

        if (this.isCastActionable(sender)) {
          this.showSpinner = true;
          this.castSeek(time);
          window.clearInterval(this._timerHandle);
        }
      },

      /**
       * Play
       * @param {cast.CastManager.SENDER} sender requesting element
       */
      play: function (sender) {
        console.log('Play: ' + JSON.stringify(sender));
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'play',
            'sender': sender
          }
        });
        // If the action is cast actionable, play the cast media
        if (this.isCastActionable(sender)) {
          this._showSpinner();
          this.castPlay();
        } else if (this.session && this.session.status === chrome.cast.SessionStatus.CONNECTED && !this.hasCastMedia) {
          // If cast has no media, load the local media before playing it
          this._showSpinner();
          this.loadMediaOntoCast(this.localMedia, true);
        }
      },

      /**
       * Pause
       * @param {cast.CastManager.SENDER} sender requesting element
       */
      pause: function (sender) {
        console.log('Pause: ' + JSON.stringify(sender));

        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'pause',
            'sender': sender
          }
        });

        if (this.isCastActionable(sender)) {
          this.castPause();
        }
      },

      /**
       * Set Volume
       *
       * @param {Number} volume number between 0 - 1 representing volume
       * @param {cast.CastManager.SENDER} sender requesting element
       */
      setVolume: function (volume, sender) {
        console.log('Setting volume: ' + volume);

        // Fire an event to notify elements of the volume change
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'volume',
            'volume': volume,
            'sender': sender
          }
        });
        if (this.isCastActionable(sender)) {
          this.castVolume(volume);
        }
      },

      /**
       * Sets the current video duration.
       *
       * @param {Number} time duration of content in seconds
       */
      setDuration: function (time) {
        console.log('Setting duration: ' + time);
        this.localMedia.setDuration(time);
      },

      /**
       * Displays the preload dialog which notifies users of the next video in queue.
       *
       * @param {cast.MediaItem} media next video in queue
       * @param {Number} time time until next video starts
       */
      showPreloadDialog: function (media, time) {
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'preload',
            'media': media,
            'timeRemaining': timeRemaining
          }
        });
      },

      /**
       * Hide the preload dialog.  Fires an iron event to notify all subscribed elements
       */
      hidePreloadDialog: function () {
        console.log('Hiding preload dialog');
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'hideDialog'
          }
        });
      },

      /**
       * Sets the autoplay trigger for the next loaded local video
       *
       * @param {Boolean} trigger whether the next video should autoplay
       */
      setAutoPlayTrigger: function (trigger) {
        console.log('Setting auto play trigger to: ' + trigger);
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'autoPlayTrigger',
            'value': trigger
          }
        });
      },
      /************* Cast control methods *************/
      /**
       * Seek
       *
       * @param {Number} time time in seconds to seek to
       */
      castSeek: function (time) {
        var request = new chrome.cast.media.SeekRequest();
        request.currentTime = Math.round(time);
        this.castMedia.seek(request,
            this._onGenericSuccess.bind(this), this._onGenericFailure.bind(this));
      },

      /**
       * Pause media on cast
       */
      castPause: function () {
        this.castMedia.pause(new chrome.cast.media.PauseRequest(),
            this._onGenericSuccess.bind(this),
            this._onGenericFailure.bind(this));
      },

      /**
       * Play media on cast
       */
      castPlay: function () {
        this.castMedia.play(new chrome.cast.media.PlayRequest(),
            this._onGenericSuccess.bind(this),
            this._onGenericFailure.bind(this));
      },

      /**
       * Set the cast volume
       * @param {Number} volume number 0 - 1 representing volume
       */
      castVolume: function (volume) {
        var vol = new chrome.cast.Volume(volume, false);
        var request = new chrome.cast.media.VolumeRequest(vol);
        this.castMedia.setVolume(request, this._onGenericSuccess.bind(this),
            this._onGenericFailure.bind(this));
      },

      /**
       * Set the cast repeat mode
       * @param {Number} mode cast repeat mode
       */
      castSetRepeat: function (mode) {
        this.castMedia.queueSetRepeatMode(chrome.cast.media.RepeatMode, this._onGenericSuccess.bind(this),
            this._onGenericFailure.bind(this));
      },

      /************* Helper methods *******************/
      /**
       * Hide the spinner and fire an iron event to notify other elements
       */
      _hideSpinner: function () {
        this.set('showSpinner', false);
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'spinner',
            'show': false
          }
        });
      },

      /**
       * Show the spinner and fire an iron event to notify other elements
       */
      _showSpinner: function () {
        this.set('showSpinner', true);
        this._fireIronEvent({
          'name': 'media-action',
          'data': {
            'action': 'spinner',
            'show': true
          }
        })
      },

      /******** Observers ********/

      /**
       * Checks the remaining time to determine if the next video preview needs to show.
       *
       * @param {Number} newVal current time in seconds
       * @param {Number} oldVal preious time in seconds
       */
      _currentTimeObserver: function (newVal, oldVal) {
        if (this.localMedia && !this.hasCastMedia) {
          var timeRemaining = this.localMedia.duration - this.currentTime;
          if (timeRemaining < 20 && timeRemaining > 0) {
            this.set('nextQueueMediaItem', this.queue.peekNextItem());
            this.set('countdownToNextMediaItem', timeRemaining);
          }
        } else if (this.hasCastMedia && this.castMedia.preloadedItemId) {
          this.set('nextQueueMediaItem', this.queue.getItemById(this.castMedia.preloadedItemId));
          this.set('countdownToNextMediaItem', this.localMedia.duration - this.currentTime);
        }
      },

      /********************* Conversion methods ***************/

      /**
       * Convert from  `chrome.cast.media.QueueItem` to `cast.MediaItem`
       * @param {chrome.cast.media.QueueItem} media item to convert
       * @return {cast.MediaItem} converted item
       */
      _castMediaToLocalMedia: function (media) {
        return new cast.MediaItem({
          'title': media.media.metadata.title,
          'url': media.media.contentId,
          'thumbnailImageUrl': media.media.metadata.images[0].url,
          'studio': media.media.metadata.subtitle,
          'description': media.media.metadata.description,
          'queueId': media.itemId,
          'duration': media.media.duration
        });
      },

      /**
       * Convert from `cast.MediaItem` to `chrome.cast.media.MediaInfo`
       *
       * @param {cast.MediaItem} media item to convert
       * @return {chrome.cast.media.MediaInfo} converted item
       */
      _localMediaToCastMedia: function (media) {
        var castMedia = new chrome.cast.media.MediaInfo(media.url);
        castMedia.metadata = new chrome.cast.media.GenericMediaMetadata();
        castMedia.metadata.metadataType = chrome.cast.media.MetadataType.GENERIC;
        if((typeof media.url !== "undefined") && (media.url !== null)){
            castMedia.contentType = this._fileExtensionToMimeType(media.url);
        } else{
            castMedia.contentType = 'video/mp4';
        }
        castMedia.metadata.title = media.title;
        castMedia.metadata.subtitle = media.studio;
        castMedia.metadata.images = [{'url': media.thumbnailImageUrl}];
        castMedia.metadata.description = media.description;

        return castMedia;
      },

      /**
       * Gets mimeType from extension
       *
       * @param {String} url file name
       * @return {String} mimeType
       */
      _fileExtensionToMimeType: function (url) {
        var extension = url.split('.').pop();
        var mimeType;
        switch (extension) {
          case 'mp4':
            mimeType = 'video/mp4';
            break;
          case 'ogv':
            mimeType = 'video/ogg';
            break;
          case 'webm':
            mimeType = 'video/webm';
            break;
          case 'mp3':
            mimeType = 'audio/mpeg';
            break;
          case 'wav':
            mimeType = 'audio/wav';
            break;
        }
        return mimeType;
      },

      /**
       * Convert cast player state to local player state
       * @param {chrome.cast.media.PlayerState} state cast player state
       * @return {cast.MediaItem.STATE} local player state
       */
      _castPlayerStateToLocalPlayerState: function (state) {
        switch (state) {
          case chrome.cast.media.PlayerState.PAUSED:
            return cast.MediaItem.STATE.PAUSED;
            break;
          case chrome.cast.media.PlayerState.PLAYING:
            return cast.MediaItem.STATE.PLAYING;
            break;
          case chrome.cast.media.PlayerState.BUFFERING:
            return cast.MediaItem.STATE.BUFFERING;
            break;
          default:
            return cast.MediaItem.STATE.PAUSED;
        }
      },


      /**
       * Switch from local queue to cast queue and save the previous local queue
       *
       * @param {Array} queueItems array of new `chrome.cast.media.QueueItems` to insert into the
       * queue
       */
      _queueSwitchFromLocalToCast: function (queueItems) {
        this._savedQueue = this.queue;
        this.set('queue', new cast.QueueManager());
        this.queue.parseCastQueue(queueItems);
      },

      /**
       * Hide the spinner and reset the next video preview
       */
      _resetState: function () {
        this._hideSpinner();
        this.set('countdownToNextMediaItem', null);
        this.set('nextQueueMediaItem', null);
      },

      /**
       * Shortcut to fire an iron event
       * @param {Object} event event details
       */
      _fireIronEvent: function (event) {
        this.fire('iron-signal', event);
      },

      /**
       * Converts local queue repeat mode and shuffle mode to {chrome.cast.media.RepeatMode}
       *
       * @param {cast.QueueManager} queue local queue
       * @returns {chrome.cast.media.RepeatMode} cast repeat mode
       */
      _localQueueToCastQueueRepeatMode: function (queue) {
        if (queue.shuffle) {
//          return chrome.cast.media.RepeatMode.ALL_AND_SHUFFLE;  // bug in extension
          return 'REPEAT_ALL_AND_SHUFFLE';
        } else {
          switch (queue.repeatMode) {
            case cast.QueueManager.REPEAT_MODE.NONE:
              return chrome.cast.media.RepeatMode.OFF;
              break;
            case cast.QueueManager.REPEAT_MODE.REPEAT_ALL:
              return chrome.cast.media.RepeatMode.ALL;
              break;
            case cast.QueueManager.REPEAT_MODE.REPEAT_SINGLE:
              return chrome.cast.media.RepeatMode.SINGLE;
              break;
          }
        }
      },

      /**
       * Converts cast repeat mode to local repeat mode
       * @param {chrome.cast.media.RepeatMode} mode cast repeat mode
       * @return {cast.QueueManager.REPEAT_MODE} local repeat mode
       */
      _castQueueRepeatModeToLocalRepeatMode: function (mode) {
        switch (mode) {
          case chrome.cast.media.RepeatMode.OFF:
            return cast.QueueManager.REPEAT_MODE.NONE;
            break;
          case chrome.cast.media.RepeatMode.ALL:
            return cast.QueueManager.REPEAT_MODE.REPEAT_ALL;
            break;
          case chrome.cast.media.RepeatMode.SINGLE:
            return cast.QueueManager.REPEAT_MODE.REPEAT_SINGLE;
            break;
          default:
            return cast.QueueManager.REPEAT_MODE.REPEAT_ALL;
        }
      },

      /**
       * Converts cast repeat mode to local shuffle mode
       * @param {chrome.cast.media.RepeatMode} mode  cast repeat mode
       * @return {Boolean} boolean describing if shuffle is on.
       */
      _castQueueRepeatModeToLocalShuffle: function (mode) {
        return mode === chrome.cast.media.RepeatMode.ALL_AND_SHUFFLE;
      }
    });

    /**
     * Defines the sender of the request
     *
     * @type {{LOCAL: number, CHROMECAST: number}}
     */
    CastManager.SENDER = {
      'LOCAL': 0, //local video
      'CHROMECAST': 1, //chromecast events ie. for multiple senders
      'CASTCONTROLLER': 2 //cast controller bar
    };
    CastManager.CONNECTION_STATUS = {
      'DISCONNECTED': 0,
      'CONNECTING': 1,
      'CONNECTED': 2
    };
    CastManager.QUEUE_REPEAT_MODE = {
      'NONE': 0,
      'REPEAT_ALL': 1,
      'REPEAT_SINGLE': 2
    };

    cast.CastManager = CastManager;
  })();
</script>
